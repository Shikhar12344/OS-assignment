# -*- coding: utf-8 -*-
"""OS Lab Assignment3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Pio6_N0pepjYoYDTsim15vICDJQ_RLGr
"""

# Task 1: Priority + Round Robin Scheduling

def priority_scheduling():
    processes = []
    n = int(input("Enter number of processes: "))

    for i in range(n):
        bt = int(input(f"Enter Burst Time for P{i+1}: "))
        pr = int(input(f"Enter Priority (lower = higher) for P{i+1}: "))
        processes.append([i+1, bt, pr])

    processes.sort(key=lambda x: x[2])  # Sort by Priority (Ascending)

    wt = 0
    total_wt = 0
    total_tt = 0

    print("\nPriority Scheduling:")
    print("PID\tBT\tPriority\tWT\tTAT")

    for pid, bt, pr in processes:
        tat = wt + bt
        print(f"{pid}\t{bt}\t{pr}\t\t{wt}\t{tat}")
        total_wt += wt
        total_tt += tat
        wt += bt

    print(f"Average Waiting Time: {total_wt / n:.2f}")
    print(f"Average Turnaround Time: {total_tt / n:.2f}")


def round_robin():
    print("\nRound Robin Scheduling:")
    n = int(input("Enter number of processes: "))
    bt = []
    for i in range(n):
        bt.append(int(input(f"Enter Burst Time for P{i+1}: ")))

    qt = int(input("Enter Time Quantum: "))

    rem_bt = bt.copy()
    t = 0
    wt = [0] * n

    while True:
        done = True
        for i in range(n):
            if rem_bt[i] > 0:
                done = False
                if rem_bt[i] > qt:
                    t += qt
                    rem_bt[i] -= qt
                else:
                    t += rem_bt[i]
                    wt[i] = t - bt[i]
                    rem_bt[i] = 0
        if done:
            break

    print("\nPID\tBT\tWT\tTAT")
    total_wt = 0
    total_tat = 0
    for i in range(n):
        tat = bt[i] + wt[i]
        print(f"P{i+1}\t{bt[i]}\t{wt[i]}\t{tat}")
        total_wt += wt[i]
        total_tat += tat

    print(f"Average Waiting Time: {total_wt / n:.2f}")
    print(f"Average Turnaround Time: {total_tat / n:.2f}")


priority_scheduling()
round_robin()

#Task 2: Sequential File Allocation

total_blocks = int(input("Enter total number of blocks: "))
block_status = [0] * total_blocks

n = int(input("Enter number of files: "))

for i in range(n):
    start = int(input(f"Enter starting block for file {i+1}: "))
    length = int(input(f"Enter length of file {i+1}: "))

    allocated = True

    for j in range(start, start + length):
        if j >= total_bloc5
        ks or block_status[j] == 1:
            allocated = False
            break

    if allocated:
        for j in range(start, start + length):
            block_status[j] = 1
        print(f"File {i+1} allocated from block {start} to {start + length - 1}")
    else:
        print(f"File {i+1} cannot be allocated!")

#Task 3: Indexed File Allocation

total_blocks = int(input("Enter total number of blocks: "))
block_status = [0] * total_blocks

n = int(input("Enter number of files: "))

for i in range(n):
    index = int(input(f"Enter index block for file {i+1}: "))

    if block_status[index] == 1:
        print("Index block already allocated!")
        continue

    count = int(input("Enter number of data blocks: "))
    data_blocks = list(map(int, input("Enter block numbers: ").split()))

    if len(data_blocks) != count or any(block_status[b] == 1 for b in data_blocks):
        print("Error: Duplicate or invalid blocks.")
        continue

    block_status[index] = 1
    for blk in data_blocks:
        block_status[blk] = 1

    print(f"File {i+1} -> Index Block {index} : {data_blocks}")

# Task 4: Memory Allocation - First Fit / Best Fit / Worst Fit

def allocate_memory(strategy):
    print(f"\n--- {strategy.upper()} FIT ---")
    partitions = list(map(int, input("Enter partition sizes: ").split()))
    processes = list(map(int, input("Enter process sizes: ").split()))

    allocation = [-1] * len(processes)

    for i, p in enumerate(processes):
        idx = -1
        if strategy == "first":
            for j, part in enumerate(partitions):
                if part >= p:
                    idx = j
                    break

        elif strategy == "best":
            best = float("inf")
            for j, part in enumerate(partitions):
                if part >= p and part < best:
                    best = part
                    idx = j

        elif strategy == "worst":
            worst = -1
            for j, part in enumerate(partitions):
                if part >= p and part > worst:
                    worst = part
                    idx = j

        if idx != -1:
            allocation[i] = idx
            partitions[idx] -= p

    for i, a in enumerate(allocation):
        if a != -1:
            print(f"Process P{i+1} allocated â†’ Partition {a+1}")
        else:
            print(f"Process P{i+1} cannot be allocated")


allocate_memory("first")
allocate_memory("best")
allocate_memory("worst")

#Task 5: MFT & MVT Memory Management
 #Implement MFT (fixed partitions) and MVT (variable partitions) strategies in Python.
def MFT():
    mem_size = int(input("Enter total memory size: "))
    part_size = int(input("Enter partition size: "))
    n = int(input("Enter number of processes: "))
    partitions = mem_size // part_size
    print(f"Memory divided into {partitions} partitions")
    for i in range(n):
        psize = int(input(f"Enter size of Process {i+1}: "))
        if psize <= part_size:
            print(f"Process {i+1} allocated.")
        else:
            print(f"Process {i+1} too large for fixed partition.")

def MVT():
    mem_size = int(input("Enter total memory size: "))
    n = int(input("Enter number of processes: "))
    for i in range(n):
        psize = int(input(f"Enter size of Process {i+1}: "))
        if psize <= mem_size:
            print(f"Process {i+1} allocated.")
            mem_size -= psize
        else:
            print(f"Process {i+1} cannot be allocated. Not enough memory.")

print("MFT Simulation:")
MFT()
print("\nMVT Simulation:")
MVT()